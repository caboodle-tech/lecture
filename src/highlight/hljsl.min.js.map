{"version":3,"file":"hljsl.min.js","sources":["../src/hljsl.js"],"sourcesContent":["let autoRunCompleted = false;\n\n/* eslint-disable no-param-reassign */\nclass HighlightLite {\n\n    #autoLoad = true;\n\n    #hideNumbers = false;\n\n    #ignoreElements = [];\n\n    #lang = 'en-us';\n\n    #lazyLoad = true;\n\n    #onlyAutoProcess = ['body'];\n\n    #root = '';\n\n    #worker = null;\n\n    #version = '1.1.0';\n\n    constructor(config = {}) {\n        this.#initialize();\n        // Set or check for alternative config options.\n        if (Object.keys(config).length === 0) {\n            this.#checkForGlobalConfig();\n        } else {\n            this.setConfig(config);\n        }\n        // Only the primary instance of HLJSL should auto run.\n        if (autoRunCompleted) { return; }\n        autoRunCompleted = true;\n        this.#waitForBody();\n    }\n\n    /**\n     * Watch a block for intersection events and when it appears to be coming up\n     * in the viewport (or already showing), process the block. This is used to\n     * lazy process (load) code blocks.\n     *\n     * @param {Array} entries An array of observed events that have triggered this function.\n     * @param {IntersectionObserver} observer The observer watching this element/event.\n     */\n    #blockInView(entries, observer) {\n        entries.forEach((entry) => {\n            if (entry.isIntersecting) {\n                observer.disconnect(); // Block is about to be processed so stop watching it.\n                this.highlight(entry.target);\n            }\n        });\n    }\n\n    /**\n     * Helper method that checks for and uses the users global config if set.\n     */\n    #checkForGlobalConfig() {\n        const globalConfig = window.hljslConfig;\n        if (!globalConfig) { return; }\n        this.setConfig(globalConfig);\n    }\n\n    /**\n     * Create a unique id.\n     *\n     * @returns {string} A generally unique id.\n     */\n    createId() {\n        return `${Date.now().toString(36)}${Math.random().toString(36).substring(2)}`.toUpperCase();\n    }\n\n    /**\n     * Connect to HLJSL's web worker.\n     *\n     * @returns {void} Used as a short circuit only.\n     */\n    connect() {\n        if (this.#worker) {\n            return;\n        }\n        const worker = new Worker(`${this.#root}/hljsl-worker.min.js`);\n        worker.onmessage = this.#receiveResponse.bind(this);\n        this.#worker = worker;\n    }\n\n    /**\n     * Copy code from a block to the users clipboard.\n     *\n     * @param {HTMLElement} button The copy to clipboard button that was pressed.\n     * @returns {void} Used as a short circuit.\n     */\n    copyToClipboard(button) {\n        const table = button.nextElementSibling;\n        if (table.nodeName !== 'TABLE') { return; }\n        // Visually show the table is being copied.\n        button.ariaPressed = true;\n        table.classList.add('copy-to-clipboard');\n        // Actually copy the table to the users clipboard:\n        const cells = table.querySelectorAll('tr td:nth-child(2)');\n        // Copy data to a temporary div.\n        const tmpDiv = document.createElement('div');\n        cells.forEach((cell) => {\n            tmpDiv.textContent += `${cell.textContent}\\n`;\n        });\n        // Copy the text from the temporary div to the clipboard using the Clipboard API.\n        navigator.clipboard.writeText(tmpDiv.textContent.trimEnd())\n            .catch((error) => {\n                console.error('Failed to copy text to clipboard:', error);\n            });\n        // Remove the visual effect.\n        setTimeout(() => {\n            table.classList.remove('copy-to-clipboard');\n            button.ariaPressed = false;\n        }, 500);\n    }\n\n    /**\n     * Correct the padding of code blocks.\n     *\n     * @param {HTMLElement} elem The code element to process.\n     */\n    #correctPadding(elem) {\n        // Don't waste time reprocessing a block.\n        if (elem.classList.contains('fixed-padding')\n            || elem.parentElement.classList.contains('fixed-padding')\n            || elem.querySelector('fixed-padding')\n        ) { return elem; }\n        // Enforce proper <pre><code> structure.\n        let pre;\n        let code;\n        if (elem.nodeName === 'PRE') {\n            // Correct pre element.\n            pre = elem;\n            code = elem.querySelector('code');\n            if (!code) {\n                // Incorrect code element.\n                code = document.createElement('CODE');\n                code.innerText = pre.innerText;\n                pre.innerHTML = '';\n                pre.appendChild(code);\n            }\n        } else if (elem.nodeName === 'CODE') {\n            // Correct code element.\n            pre = elem.closest('pre');\n            code = elem;\n            if (!pre) {\n                // Incorrect pre element.\n                pre = document.createElement('PRE');\n                code.parentElement.insertBefore(pre, elem);\n                pre.appendChild(code);\n            }\n        } else {\n            // Pre and code missing entirely.\n            pre = document.createElement('PRE');\n            code = document.createElement('CODE');\n            code.innerText = elem.innerHTML;\n            pre.appendChild(code);\n            elem.parentElement.insertBefore(pre, elem);\n            elem.parentElement.removeChild(elem);\n        }\n        // Break the code into their lines for processing.\n        const lines = code.innerText.split('\\n');\n        /**\n         * Remove empty lines from the start and end of the code. We cannot\n         * use trim because it will wipe the indentation we are trying to find.\n         */\n        let startIndex = 0;\n        let endIndex = lines.length - 1;\n        // Find the index of the first non-empty line from the start.\n        while (startIndex < lines.length && lines[startIndex].trim() === '') {\n            startIndex += 1;\n        }\n        // Find the index of the first non-empty line from the end.\n        while (endIndex >= 0 && lines[endIndex].trim() === '') {\n            endIndex -= 1;\n        }\n        // Calculate the number of empty lines to remove from the start and end.\n        const numEmptyLinesAtStart = startIndex;\n        const numEmptyLinesAtEnd = lines.length - 1 - endIndex;\n        // Remove the empty lines from the start and end of the array.\n        lines.splice(0, numEmptyLinesAtStart);\n        lines.splice(lines.length - numEmptyLinesAtEnd, numEmptyLinesAtEnd);\n        // Just in case we were given a bad code block save it from erroring out here.\n        if (lines.length === 0) { lines.push(''); }\n        // Count the spaces from the first line, this indicates the indentation we need to remove.\n        const match = lines[0].match(/^\\s+/);\n        const indentation = match ? match[0].length : 0;\n        // Remove the unnecessary indentation (padding) at the start of each line.\n        lines.forEach((line, i) => {\n            lines[i] = line.substring(indentation);\n        });\n        // Mark the pre tag as highlight.js\n        pre.classList.add('hljs');\n        // Make the replacement in the DOM and remove any extra empty new line at the end.\n        code.innerText = lines.join('\\n').trim();\n        code.classList.add('fixed-padding');\n        pre.innerHTML = pre.innerHTML.trim(); // This breaks the users DOM reference!\n        return pre.firstElementChild; // Must return the new code element.\n    }\n\n    /**\n     * Disconnect from HLJSL's web worker.\n     *\n     * @returns {void} Used as a short circuit.\n     */\n    disconnect() {\n        if (!this.#worker) {\n            return;\n        }\n        this.#worker.terminate();\n        this.#worker = null;\n    }\n\n    /**\n     * Check the status of the page being auto loaded (processed).\n     *\n     * @returns {boolean} True if the primary HLJSL instance auto loaded (processed) the page.\n     */\n    getAutoRunStatus() {\n        return autoRunCompleted;\n    }\n\n    /**\n     * Helper method to return the true innerText in a more reliant and performant way. According to\n     * the standards, if an element or its text is hidden by CSS then no newlines are added to the\n     * result of innerText. Any call to innerText also triggers a redraw since the elements style\n     * has to be taken into account. Here we work around these issues (cheat) by using innerHTML and\n     * replacing the <br> (line break) tags with newlines.\n     *\n     * @param {HTMLElement} elem The element to get the true innerText from.\n     *\n     * @returns {string} The innerText always including newlines.\n     */\n    #getTrueInnerText(elem) {\n        return elem.innerHTML.replace(/<br\\s*\\/?>/gi, '\\n');\n    }\n\n    /**\n     * Build the querySelectorAll string to search and find all specified elements.\n     *\n     * @param {array} find An array of element tags, classes prefixed with the css dot (.), and/or\n     *                     ids prefixed with the css pound (#) to locate in the page.\n     *\n     * @returns {string} The querySelectorAll string to locate all your requested elements.\n     */\n    getQuerySelectorFindAllString(find = []) {\n        if (find.length === 0) { return ''; }\n        return find.join(', ');\n    }\n\n    /**\n     * Builds the query string meant to be used with querySelectorAll and allows not searching\n     * within classes, ids, and/or elements.\n     *\n     * @param {string} find The query selector you would like to find.\n     * @param {array} notWithin An array of element tags, classes prefixed with the css dot (.), and/or\n     *                          ids prefixed with the css pound (#) to not search in.\n     *\n     * @returns {string} The proper query selector string to use with querySelectorAll.\n     */\n    getQuerySelectorNotWithinString(find, notWithin = []) {\n        if (notWithin.length === 0) { return find; }\n        const ignoredSelectors = notWithin.join(', ');\n        return `:not(${ignoredSelectors}) > ${find}`;\n    }\n\n    /**\n     * Detect what language the user is viewing the page in.\n     *\n     * @returns {string} The users valid BCP 47 language code.\n     */\n    getUserLanguage() {\n        // Start with the browsers language setting.\n        let userLanguage = navigator.language || navigator.userLanguage;\n        // Check if lang attribute is set in the HTML tag.\n        const htmlLang = document.documentElement.lang;\n        if (htmlLang) {\n            // Check if the lang attribute is a valid BCP 47 language tag.\n            const langRegex = /^[a-zA-Z]{2}(-[a-zA-Z]{2})?$/;\n            if (langRegex.test(htmlLang)) {\n                // Use the language that the developer set instead.\n                userLanguage = htmlLang;\n            }\n        }\n        return userLanguage;\n    }\n\n    /**\n     * Share the version of HLJSL being used.\n     *\n     * @returns  {string} The current version on HLJSL.\n     */\n    getVersion() {\n        return this.#version;\n    }\n\n    /**\n     * Highlight a code element with HLJS using the HLJSL web worker.\n     *\n     * @param {HTMLElement} elem The code element to highlight.\n     */\n    highlight(elem) {\n        // If the web worker is not connected do so now.\n        if (!this.isConnected()) {\n            /**\n             * NOTE: We do not connect automatically in case this page doesn't\n             * have any code blocks to highlight.\n             */\n            this.connect();\n        }\n        // Do not waste time reprocessing a block.\n        if (elem.hasAttribute('hljsl-id')) { return; }\n        /**\n         * This should have been added already but a deferred code block that the\n         * user wants to manually process will be missing this.\n         */\n        if (this.#hideNumbers) {\n            elem.parentElement.classList.add('hide-numbers');\n        }\n        elem = this.#correctPadding(elem);\n        /**\n         * This should have been added already but a deferred code block that the\n         * user wants to manually process will be missing this.\n         */\n        elem.parentElement.classList.add('hljs');\n        // eslint-disable-next-line no-param-reassign\n        elem.dataset.hljslId = this.createId();\n        const msg = {\n            code: this.#getTrueInnerText(elem),\n            codeLang: elem.classList.toString(),\n            id: elem.dataset.hljslId,\n            pageLang: this.#lang,\n            root: this.#root\n        };\n        // Message the web worker.\n        this.#worker.postMessage(JSON.stringify(msg));\n    }\n\n    /**\n     * Process all code blocks found within the provided container (element) or leave empty and the\n     * user/global settings will be used to find blocks to process.\n     *\n     * @param {HTMLElement} container The element to search for code blocks within to highlight.\n     */\n    highlightAll(container) {\n        // eslint-disable-next-line no-param-reassign\n        if (!container) {\n            // No container was provided so process according to the users/global settings.\n            const selector = this.getQuerySelectorNotWithinString('pre code', this.#ignoreElements);\n            const autoProcess = this.getQuerySelectorFindAllString(this.#onlyAutoProcess);\n            const elems = document.querySelectorAll(autoProcess);\n            elems.forEach((elem) => {\n                const blocks = elem.querySelectorAll(selector);\n                blocks.forEach((block) => {\n                    // Process each code block found.\n                    this.highlight(block);\n                });\n            });\n            return;\n        }\n        // Find all the code blocks in the provided element.\n        const codeBlocks = container.querySelectorAll('pre code');\n        codeBlocks.forEach((block) => {\n            // Process each code block found.\n            this.highlight(block);\n        });\n    }\n\n    /**\n     * Initializes HLJSL by determining its root location and checking for various options (settings).\n     */\n    #initialize() {\n        // Set the apps language.\n        this.#lang = this.getUserLanguage();\n        // Determine the root (directory) location of HLJSL.\n        this.#root = window?.location?.origin;\n        let hljsScriptSrc = '';\n        const scripts = document.getElementsByTagName('script');\n        for (let i = 0; i < scripts.length; i++) {\n            const { src } = scripts[i];\n            if (src.includes('/hljsl')) {\n                if (src.indexOf('?')) {\n                    hljsScriptSrc = src.substring(src.indexOf('?'));\n                }\n                this.#root = src.substring(0, src.indexOf('/hljsl'));\n                break;\n            }\n        }\n        // Check for and configure various options (settings).\n        const urlParams = new URLSearchParams(hljsScriptSrc);\n        if (urlParams.get('autoLoad')) {\n            this.#autoLoad = this.isTrue(urlParams.get('autoLoad'));\n        }\n        if (urlParams.get('hideNumbers')) {\n            this.#hideNumbers = this.isTrue(urlParams.get('hideNumbers'));\n        }\n        if (urlParams.get('lazyLoad')) {\n            this.#lazyLoad = this.isTrue(urlParams.get('lazyLoad'));\n        }\n    }\n\n    /**\n     * Check if HLJSL's Web worker is connected.\n     *\n     * @returns {boolean} Boolean indicating the web worker connection state; true is connected.\n     */\n    isConnected() {\n        return !(this.#worker === null);\n    }\n\n    /**\n     * Convert a string representing a boolean into an actual boolean.\n     *\n     * @param {string} str The string to convert to the correct boolean value.\n     * @returns\n     */\n    isTrue(str) {\n        if (typeof (str) === 'string') {\n            str = str.trim().toLowerCase();\n        }\n        switch (str) {\n            case true:\n            case 'true':\n            case 1:\n            case '1':\n            case 'on':\n            case 'yes':\n                return true;\n            default:\n                return false;\n        }\n    }\n\n    #processBlock(block) {\n        // Process blocks now or lazy load them?\n        if (!this.#lazyLoad) {\n            // Process blocks now.\n            this.highlight(block);\n            return;\n        }\n        // Lazy load blocks instead; recommended for pages with many code blocks.\n        const blockObserverOptions = {\n            root: null,\n            rootMargin: '100%',\n            threshold: 0\n        };\n        const blockObserver = new IntersectionObserver(\n            this.#blockInView.bind(this),\n            blockObserverOptions\n        );\n        blockObserver.observe(block);\n    }\n\n    /**\n     * Automatically process code blocks according to the default or global settings.\n     */\n    #processBlocks() {\n        // We automatically fix all code block padding and show or hide line numbers no matter what.\n        document.body.querySelectorAll('pre code').forEach((block) => {\n            // Before fixing the padding check if we need to hide line numbers.\n            if (this.#hideNumbers) {\n                block.classList.add('hide-numbers');\n            }\n            this.#correctPadding(block);\n        });\n        // Now process the page according to the users/global settings.\n        const selector = this.getQuerySelectorNotWithinString('pre code', this.#ignoreElements);\n        const autoProcess = this.getQuerySelectorFindAllString(this.#onlyAutoProcess);\n        const elems = document.querySelectorAll(autoProcess);\n        elems.forEach((elem) => {\n            const blocks = elem.querySelectorAll(selector);\n            blocks.forEach((block) => {\n                // Stop processing if autoLoad is false; we only fix the padding and spacing.\n                if (!this.#autoLoad) { return; }\n                this.#processBlock(block);\n            });\n        });\n    }\n\n    /**\n     * Receives the response from HLJSL's web worker.\n     *\n     * @param {MessageEvent} evt The response from HLJSL's web worker.\n     */\n    #receiveResponse(evt) {\n        const msg = JSON.parse(evt.data);\n        // Using the elements id to locate the actual element.\n        const elem = document.querySelector(`[data-hljsl-id=\"${msg.id}\"]`);\n        // Clean the response just in case an empty newline snuck in at the end.\n        elem.innerHTML = msg.code.trim();\n        // Place the code block on the same line as the pre block to remove those empty lines.\n        elem.parentElement.innerHTML = elem.outerHTML.trim();\n        /**\n         * Make sure the code block has a HLJS language tag. If it already does then this should be\n         * the same that was used during the processing. If you were missing the language tag this\n         * will be the language HLJS detected this code to be.\n         */\n        elem.classList.add(msg.language);\n    }\n\n    /**\n     * Allows changing the default settings being used by this instance of HLJSL.\n     *\n     * @param {object} config The settings you would like to set.\n     * @returns\n     */\n    setConfig(config) {\n        if (this.whatIs(config) !== 'object') { return; }\n\n        if (this.whatIs(config.autoLoad) === 'boolean') {\n            this.#autoLoad = config.autoLoad;\n        }\n\n        if (this.whatIs(config.hideNumbers) === 'boolean') {\n            this.#hideNumbers = config.hideNumbers;\n        }\n\n        if (this.whatIs(config.ignoreElements) === 'array') {\n            this.#ignoreElements = config.ignoreElements;\n        }\n\n        if (this.whatIs(config.lang) === 'string') {\n            this.#lang = config.lang;\n        }\n\n        if (this.whatIs(config.lazyLoad) === 'boolean') {\n            this.#lazyLoad = config.lazyLoad;\n        }\n\n        if (this.whatIs(config.onlyAutoProcess) === 'array') {\n            if (config.onlyAutoProcess.length > 0) {\n                this.#onlyAutoProcess = config.onlyAutoProcess;\n            }\n        }\n    }\n\n    /**\n     * Using a mutation observer watch for pre code blocks being added to the page\n     * and immediately start to process them.\n     */\n    #waitForBody() {\n        const bodyObserver = new MutationObserver((mutationList, observer) => {\n            for (let i = 0; i < mutationList.length; i++) {\n                const mutation = mutationList[i];\n                // Do no process unnecessary events; ignores attribute events.\n                if (mutation.type !== 'childList') {\n                    // eslint-disable-next-line no-continue\n                    continue;\n                }\n                // Skip all elements that are not the body.\n                if (mutation.target.nodeName !== 'BODY') {\n                    // eslint-disable-next-line no-continue\n                    continue;\n                }\n                /**\n                 * Stop the observer to reduce resource use on this page. If any\n                 * code blocks are added later the user will need to manually\n                 * call the `highlight` or `highlightAll` methods.\n                 */\n                observer.disconnect();\n                /**\n                 * Body element has been added to the DOM so search it and process\n                 * all the code blocks found inside it.\n                 */\n                this.#processBlocks();\n                return; // Kill the loop so we don't trigger another reprocessing!\n            }\n        });\n        // Start the observer.\n        bodyObserver.observe(document.documentElement, { childList: true, subtree: true });\n    }\n\n    /**\n     * The fastest way to get the actual type of anything in JavaScript.\n     *\n     * {@link https://jsbench.me/ruks9jljcu/2 | See benchmarks}.\n     *\n     * @param {*} unknown Anything you wish to check the type of.\n     * @return {string|undefined} The type in lowercase of the unknown value passed in or undefined.\n     */\n    whatIs(unknown) {\n        try {\n            return ({}).toString.call(unknown).match(/\\s([^\\]]+)/)[1].toLowerCase();\n        } catch (e) { return undefined; }\n    }\n\n}\n\n// Primary instance of HLJSL that auto precesses the page.\nwindow.hljsl = new HighlightLite();\n\n// Rollup will create an iife adding HighlightLite globally to the window as HLJSL.\nexport default HighlightLite;\n"],"names":["autoRunCompleted","HighlightLite","autoLoad","hideNumbers","ignoreElements","lang","lazyLoad","onlyAutoProcess","root","worker","version","constructor","config","this","initialize","Object","keys","length","checkForGlobalConfig","setConfig","waitForBody","blockInView","entries","observer","forEach","entry","isIntersecting","disconnect","highlight","target","globalConfig","window","hljslConfig","createId","Date","now","toString","Math","random","substring","toUpperCase","connect","Worker","onmessage","receiveResponse","bind","copyToClipboard","button","table","nextElementSibling","nodeName","ariaPressed","classList","add","cells","querySelectorAll","tmpDiv","document","createElement","cell","textContent","navigator","clipboard","writeText","trimEnd","catch","error","console","setTimeout","remove","correctPadding","elem","contains","parentElement","querySelector","pre","code","innerText","innerHTML","appendChild","closest","insertBefore","removeChild","lines","split","startIndex","endIndex","trim","numEmptyLinesAtStart","numEmptyLinesAtEnd","splice","push","match","indentation","line","i","join","firstElementChild","terminate","getAutoRunStatus","getTrueInnerText","replace","getQuerySelectorFindAllString","find","getQuerySelectorNotWithinString","notWithin","getUserLanguage","userLanguage","language","htmlLang","documentElement","test","getVersion","isConnected","hasAttribute","dataset","hljslId","msg","codeLang","id","pageLang","postMessage","JSON","stringify","highlightAll","container","selector","autoProcess","block","location","origin","hljsScriptSrc","scripts","getElementsByTagName","src","includes","indexOf","urlParams","URLSearchParams","get","isTrue","str","toLowerCase","processBlock","IntersectionObserver","rootMargin","threshold","observe","processBlocks","body","evt","parse","data","outerHTML","whatIs","MutationObserver","mutationList","mutation","type","childList","subtree","unknown","call","e","hljsl"],"mappings":"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"}